{
  "Hello, world!": "Hello, world!",
  "WelcomeMessage": "Welcome to <1>Private Meet</1>",
  "IntroductionText": "Private Meet is a lightweight, secure space for instant private meetings. Create a user, generate a room, and connect — no friction, no noise.",
  "Username": "Username",
  "EnterYourUsername": "Enter your username",
  "CreateUser": "Create User",

  "SEO": {
    "Title": "Private Meet — Private Chat & WebRTC Meetings",
    "Description": "Private Meet is a privacy-first real-time chat and meeting app. Roadmap includes end-to-end encrypted temporary messages, file sharing, and WebRTC voice/video.",
    "OgAndTwitterDescription": "Privacy-first real-time chat. Roadmap: end-to-end encryption, ephemeral messages, file sharing, and WebRTC voice/video.",
    "NonScriptMsg": "You need to enable JavaScript to run this app."
  },

  "Header": {
    "Home": "Home",
    "About": "About",
    "ChangeLanguage": "Change Language"
  },

  "Footer": {
    "PrivacyPolicy": "Privacy Policy",
    "TermsOfService": "Terms of Service",
    "ContactUs": "Contact Us",
    "GithubRepository": "GitHub Repository",
    "CreatedBy": "Created by Gabriel Logan"
  },

  "Loading": {
    "LoadingDotDotDot": "Loading..."
  },

  "Errors": {
    "AnErrorOccurred": "An error occurred.",
    "AnErrorOccurredWithMessage": "An error occurred: {{message}}",
    "SomethingWentWrong": "Something went wrong.",
    "FailedToCreateUser": "Failed to create user.",
    "PleaseEnterRoomID": "Please enter a Room ID.",
    "RoomIDIsTooLong": "Room ID is too long (maximum is {{maxRoomIDLength}} characters).",
    "ErrorProcessingServerMessage": "Error processing server message.",
    "AudioTrackNotReady": "Audio track is not ready.",
    "VideoTrackNotReady": "Video track is not ready.",
    "OnlyImageFilesAllowed": "Only image files are allowed.",
    "NoPeersInRoom": "No peers in the room.",
    "WebRTCNotFullyConnectedWithAllPeers": "WebRTC is not fully connected with all peers.",
    "NoCameraTrackAvailable": "No camera track available.",
    "NoMicrophoneTrackAvailable": "No microphone track available.",
    "NoScreenShareTrackAvailable": "No screen share track available.",
    "MissingRoomID": "Missing Room ID.",
    "RefusingToCreatePeerConnToSelf": "Refusing to create peer connection to self.",
    "MaxPeerConnectionsReached": "Max peer connections reached ({{maxPeerConnections}}).",
    "UseWebRTCMeshFailedToGetUserMediaAudioWhileCreatingPeer": "[useWebRTCMesh] Failed to getUserMedia(audio) while creating peer.",
    "FailedToRevokeObjectURL": "Failed to revoke object URL.",
    "FailedToInitE2EE": "Failed to initialize E2EE.",
    "WsIsNotConnected": "WebSocket is not connected.",
    "NotConnectedYetTryAgainInASecond": "Not connected yet. Try again in a second.",
    "WsConnFailed": "WebSocket connection failed.",
    "WsInstanceIsNotInitialized": "WebSocket instance is not initialized.",
    "FailedToConnectToWsServer": "Failed to connect to WebSocket.",
    "FailedToAccessCamera": "Failed to access camera.",
    "FailedToAccessMicrophone": "Failed to access microphone.",
    "NoOneInTheRoomToReceiveMessage": "No one else is in the room to receive your message.",
    "PleaseEnterAMessage": "Please enter a message.",
    "EnryptionNotReadyYet": "Encryption is not ready yet.",
    "FailedToSendEncryptedMessage": "Failed to send encrypted message.",
    "NoOneInTheRoomToSendFile": "No one else is in the room to send your file.",
    "ImageSendingIsOnlyAllowedAfterWebRTCIsConnected": "Image sending is only available after WebRTC is connected with everyone in the room.",
    "OnlyImagesAreSupportedForNow": "Only images are supported for now.",
    "ImageTooLarge": "Image too large (max {{maxImageSizeMB}}MB for now).",
    "FailedToSendImageOverWebRTC": "Failed to send image over WebRTC.",
    "PleaseCreateAUserFirst": "Please create a user first.",
    "InvalidRoom": "Invalid room.",
    "ConnectingDotDotDotTryAgainInAMoment": "Connecting... Try again in a moment.",
    "E2EENotConfiguredWhenSendMSG": "[Protected message: E2EE not configured]",
    "E2EECanNotDecryptMessage": "[Protected message: Unable to decrypt]",
    "UnknownError": "Unknown error.",
    "UnknownErrorFromServer": "Unknown error from server."
  },

  "NotFound": {
    "PageNotFoundTitle": "404 - Page Not Found",
    "PageNotFoundMessage": "The page you are looking for does not exist."
  },

  "Infos": {
    "UserDeletedSuccessfully": "User deleted. Please create a new user to continue.",
    "UserIsTypingDotDotDot": "{{username}} is typing...",
    "TwoUsersAreTypingDotDotDot": "{{username1}} and {{username2}} are typing...",
    "MultipleUsersAreTypingDotDotDot": "{{username1}}, {{username2}}, and {{count}} others are typing...",
    "UserCanNotBeBlank": "User cannot be blank."
  },

  "Success": {
    "UserCreated": "User created successfully!",
    "RoomIDGenerated": "Generated a new Room ID!"
  },

  "JoinMeeting": {
    "RoomID": "Room ID",
    "EnterRoomID": "Enter the room ID",
    "Passphrase": "Passphrase",
    "EnterPassphrase": "Enter the passphrase (optional)",
    "PText1": "Max length: {{maxRoomIDLength}} characters. Both Room ID and Passphrase.",
    "PText2": "The passphrase is used to encrypt your messages end-to-end. If you leave it blank, the room id will be used as the passphrase. It's really recommended to use a passphrase for better security. All the users in the room must use the same passphrase to communicate securely, otherwise they won't be able to read each other's messages.",
    "JoinRoomButton": "Join Room",
    "GenerateNewRoomIDButton": "Generate Random Secure Room ID",
    "DeleteUserButton": "Delete User"
  },

  "Chat": {
    "MeetingRoom": "Meeting Room",
    "AudioStartsOn": "Audio starts on.",
    "EnableCameraOrShareScreen": "Enable camera or share screen.",
    "Users": "Users",
    "Connected": "Connected",
    "ConnectingDotDotDot": "Connecting...",
    "Online": "Online",
    "Idle": "Idle",
    "Stage": "Stage",
    "RoomColon": "Room: ",
    "NoVideoYet": "No video yet.",
    "TurnOnCameraOrShareScreen": "Turn on camera or share screen to start video.",
    "Chat": "Chat",
    "EnterToSend": "Enter to send",
    "ShiftPlusEnterForNewLine": "Shift+Enter for newline",
    "InvalidImageURL": "Invalid image URL.",
    "InvalidText": "Invalid text.",
    "InvalidName": "Invalid name.",
    "Emojis": "Emojis",
    "Close": "Close",
    "Send": "Send",
    "Message": "Message",
    "WriteAMessage": "Write a message...",
    "InitializingEncryption": "Initializing encryption...",
    "You": "You",
    "YouAudio": "You (audio)",
    "YouScreen": "You (screen)",
    "MsgsAreSentViaWsE2EEEncryption": "Messages are sent via WebSocket. End-to-end encrypted.",
    "AttachImage": "Attach image",
    "WaitingForWebRTCConn": "Waiting for WebRTC connections ({{msg}})"
  },

  "About": {
    "HeroTitle": "Private meetings, minimal friction.",
    "HeroDescription": "Private Meet is a lightweight real-time chat + meeting experience available on web and desktop (Windows). It already supports client-side encrypted chat, WebRTC media, and image sharing over WebRTC data channels. Next, the focus is improving reliability and polishing the privacy model.",

    "OnThisPage": "On this page",
    "OnThisPageLinks": {
      "Today": "What exists today",
      "How": "How it works",
      "Protocol": "API & WS protocol",
      "Security": "Security & privacy",
      "Limits": "Limits & tradeoffs",
      "Config": "Config cheatsheet",
      "Deploy": "Deploy notes",
      "Faq": "FAQ"
    },

    "CtaGetStarted": "Get started",
    "CtaOpenChat": "Open chat",

    "Meta": {
      "StackLabel": "Stack",
      "StackValue": "React + WebSocket + WebRTC + Go + Wails",
      "GoalLabel": "Goal",
      "GoalValue": "Privacy-first defaults",
      "RoadmapLabel": "Roadmap",
      "RoadmapValue": "Better E2EE, ephemeral, files, reliability"
    },

    "Sections": {
      "Today": {
        "Title": "What exists today",
        "Subtitle": "These features are already available in the current version."
      },
      "How": {
        "Title": "How it works",
        "Subtitle": "A practical view of the moving parts and where data flows."
      },
      "Protocol": {
        "Title": "API & WS protocol",
        "Subtitle": "Endpoints, message types, and what to expect over the wire."
      },
      "Security": {
        "Title": "Security & privacy (high-level)",
        "Subtitle": "What the project does today, and what it explicitly does not promise yet."
      },
      "Limits": {
        "Title": "Limits & tradeoffs",
        "Subtitle": "Practical constraints that matter in real usage."
      },
      "Config": {
        "Title": "Config cheatsheet",
        "Subtitle": "Quick mental model for the root .env used by server + frontend/desktop."
      },
      "Deploy": {
        "Title": "Deploy notes",
        "Subtitle": "What a production deployment looks like for this repo today."
      },
      "Faq": {
        "Title": "FAQ",
        "Subtitle": "Quick answers to the most common questions."
      }
    },

    "CurrentCards": {
      "Rooms": {
        "Title": "Rooms + real-time text chat",
        "Description": "Join a room and exchange messages in real time over WebSocket with a responsive UI."
      },
      "Presence": {
        "Title": "Presence + typing",
        "Description": "See who's online in the room and when someone is typing."
      },
      "E2EE": {
        "Title": "Client-side encrypted chat (E2EE)",
        "Description": "Chat messages are end-to-end encrypted in the browser when participants choose the same passphrase (Web Crypto API). The server only relays encrypted payloads."
      },
      "WebRTC": {
        "Title": "WebRTC voice/video/screen share",
        "Description": "Peer-to-peer media with WebRTC (mesh). Signaling is handled over WebSocket (currently capped at ~8 peer connections per client)."
      },
      "Images": {
        "Title": "Image sharing (WebRTC data channel)",
        "Description": "Send images directly peer-to-peer in chat. Sending is enabled only when WebRTC is connected with all peers in the room."
      },
      "Desktop": {
        "Title": "Desktop app (Windows)",
        "Description": "A Wails-based desktop app is available for Windows. It uses the same backend endpoints and real-time protocol as the web app."
      }
    },

    "HowItWorksCards": {
      "Auth": {
        "Title": "Sign-in → JWT → WebSocket",
        "Description": "Clients get an access token from /auth/sign-in and use it to connect to /ws?token=<jwt>. Room events and WebRTC signaling travel over this socket."
      },
      "RoomState": {
        "Title": "Room state is server-owned",
        "Description": "The server is the single source of truth for room membership. Clients join/leave rooms and the server broadcasts a room.users snapshot."
      },
      "Media": {
        "Title": "Media is peer-to-peer",
        "Description": "Voice/video/screen share flow directly between peers via WebRTC. The server relays signaling only (SDP + ICE)."
      },
      "Images": {
        "Title": "Images via RTCDataChannel",
        "Description": "Images are shared peer-to-peer using a WebRTC data channel (images only). The UI gates sending until peers are connected."
      }
    },

    "HighLevelFlow": {
      "Title": "High-level flow",
      "Steps": {
        "Step1": "1) Sign-in → receive JWT",
        "Step2": "2) Connect to WebSocket with the JWT",
        "Step3": "3) Join a room → receive a room.users snapshot",
        "Step4": "4) Chat/typing events flow via WS",
        "Step5": "5) WebRTC offer/answer/ICE exchanged via WS",
        "Step6": "6) Media + image transfer happens peer-to-peer"
      }
    },

    "Roadmap": {
      "Title": "Where this is going",
      "Subtitle": "The next milestones to turn this into a fully private meeting experience.",
      "Cards": {
        "E2EE": {
          "Title": "Better E2EE key exchange (next)",
          "Description": "Today E2EE is passphrase-based (shared secret). Next step is a safer key agreement / exchange + better UX so users don't have to manually coordinate secrets."
        },
        "Ephemeral": {
          "Title": "Temporary messages (next)",
          "Description": "Ephemeral messages with expiration policies so chats don't live forever by default."
        },
        "Files": {
          "Title": "More file types (next)",
          "Description": "Generalize file sharing beyond images, with clear limits, previews, and privacy-first defaults."
        },
        "Turn": {
          "Title": "TURN + reliability (next)",
          "Description": "TURN can be enabled in the web client via env config, but the next step is production-grade TURN setup + better diagnostics and UX for unreliable networks."
        }
      }
    },

    "ProtocolCards": {
      "Rest": {
        "Title": "REST",
        "GetHealth": "GET /health → OK",
        "PostSignIn": "POST /auth/sign-in",
        "Note": "/auth/sign-in returns an access token used for WS auth."
      },
      "WebSocket": {
        "Title": "WebSocket",
        "Description": "Connect to /ws with a query token. Messages are JSON with type, optional room, and data.",
        "Note": "In dev, origin checks are permissive; in prod, Origin must match ALLOWED_ORIGINS."
      },
      "MessageTypes": {
        "Title": "Message types",
        "Types": {
          "T1": "chat.join / chat.leave",
          "T2": "chat.message / chat.typing",
          "T3": "room.users (server snapshot)",
          "T4": "utils.generateRoomID",
          "T5": "webrtc.offer / webrtc.answer",
          "T6": "webrtc.iceCandidate"
        },
        "Note": "The frontend type definitions are the best place to explore the schema."
      }
    },

    "SecurityCards": {
      "E2EE": {
        "Title": "E2EE for chat (client-side)",
        "Description": "Messages can be encrypted in the browser using the Web Crypto API (AES-GCM). The server relays encrypted payloads without needing to decrypt."
      },
      "KeyModel": {
        "Title": "Current key model (passphrase-based)",
        "Description": "A key is derived locally from the passphrase using PBKDF2 (salted with the room id). Everyone in the room must use the same passphrase to decrypt messages."
      },
      "Auth": {
        "Title": "Auth boundary",
        "Description": "WebSocket connections require a valid JWT. In production, the server validates the WS Origin against ALLOWED_ORIGINS."
      }
    },

    "ImportantNote": {
      "Title": "Important note",
      "Body": "Private Meet is privacy-first, but it is still evolving. Today's E2EE setup is intentionally simple (shared passphrase + local key derivation) and is not positioned as a mature, audited secure messaging protocol.",
      "Footer": "Note: Private Meet is still evolving. Some privacy and reliability improvements are planned."
    },

    "TradeoffsCards": {
      "Mesh": {
        "Title": "Mesh scalability",
        "Description": "WebRTC mesh means each participant connects to every other participant. This is capped in the client (~8 peers) to keep CPU/bandwidth manageable."
      },
      "Nat": {
        "Title": "NAT traversal",
        "Description": "Without TURN, some networks/NATs won't connect reliably. TURN can be configured in env variables; production-grade TURN is a roadmap item."
      },
      "Backpressure": {
        "Title": "Backpressure + robustness",
        "Description": "The server applies backpressure and may drop messages if overloaded to keep connections responsive. Clients can retry WS connection."
      }
    },

    "Caps": {
      "Client": {
        "Title": "Current caps (client)",
        "MsgCap": "Message UI cap: 1500 chars",
        "WebRtcPeers": "WebRTC peers: ~8",
        "ImageSize": "Image size: 12MB"
      },
      "Server": {
        "Title": "Current caps (server)",
        "RoomId": "Room ID length: up to 128 chars",
        "ChatPayload": "Chat payload: up to 5000 runes",
        "WsRead": "WS read limit: 64KB per message"
      },
      "Expect": {
        "Title": "What to expect",
        "Body": "Small rooms work best. For bigger rooms or hostile networks, TURN and/or an SFU architecture are the typical next steps."
      }
    },

    "ConfigCards": {
      "Backend": {
        "Title": "Backend (.env)",
        "Vars": {
          "V1": "GO_ENV (development / production)",
          "V2": "USE_LOCAL_TLS (true / false)",
          "V3": "SERVER_PORT",
          "V4": "ALLOWED_ORIGINS",
          "V5": "JWT_SECRET + JWT_EXPIRATION",
          "V6": "CONTEXT_TIMEOUT"
        },
        "Note": "The server loads ../.env relative to server/."
      },
      "Web": {
        "Title": "Web (Vite)",
        "Vars": {
          "V1": "VITE_HTTP_API_URL",
          "V2": "VITE_WS_API_URL",
          "V3": "VITE_HAS_TURN_SERVER",
          "V4": "VITE_TURN_SERVER_URL",
          "V5": "VITE_TURN_SERVER_USERNAME",
          "V6": "VITE_TURN_SERVER_CREDENTIAL"
        },
        "Note": "TURN is optional. If disabled, the app uses STUN only."
      },
      "SecureContext": {
        "Title": "Secure context for WebRTC",
        "Body": "Browsers require HTTPS for certain WebRTC/media capabilities when not on localhost. The Vite dev server is set up with HTTPS using local cert files."
      }
    },

    "DeployCards": {
      "Build": {
        "Title": "Build",
        "Body": "The repo builds a Go binary and a static web bundle.",
        "ServerBinary": "Server binary: server/bin/server",
        "WebAssets": "Web assets: client/frontend/dist"
      },
      "Spa": {
        "Title": "Serving the SPA",
        "Body": "The Go server serves the SPA from client/frontend/dist and falls back to index.html for client-side routes."
      },
      "Health": {
        "Title": "Health checks",
        "Body": "/health returns OK and is used by platforms like Render."
      },
      "Desktop": {
        "Title": "Desktop distribution",
        "Body": "The desktop app can be built with Wails, including a Windows installer for distribution.",
        "WindowsInstaller": "Windows installer output: distribution/windows/*.exe"
      }
    },

    "FaqItems": {
      "Q1": {
        "Q": "Do I need an account?",
        "A": "No. The current model issues a short-lived token on sign-in and lets you join rooms without user registration."
      },
      "Q2": {
        "Q": "Is this end-to-end encrypted?",
        "A": "Chat messages can be client-side encrypted when participants choose the same passphrase (shared secret). Today the key is derived locally (PBKDF2 + room id salt); longer-term the project will evolve toward a safer key exchange and better UX."
      },
      "Q3": {
        "Q": "Why do calls fail on some networks?",
        "A": "Some NAT/firewall setups require TURN. You can enable TURN in env, but a robust production TURN setup is still part of the roadmap."
      },
      "Q4": {
        "Q": "Why cap the room size / peer connections?",
        "A": "Mesh WebRTC grows quadratically with participants. The cap avoids melting CPUs and uplinks."
      }
    },

    "Footer": {
      "Title": "Want to help shape the roadmap?",
      "Subtitle": "Iterate on UX, encryption, and WebRTC features.",
      "Repo": "Repo",
      "WebRTCNotes": "WebRTC notes",
      "BackToHome": "Back to Home"
    }
  }
}
